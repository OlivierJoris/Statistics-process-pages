From 5bf88f94d4c1882e45d92198f284b6f5b7587224 Mon Sep 17 00:00:00 2001
From: Maxime Goffart <maximegoffart@icloud.com>
Date: Wed, 21 Apr 2021 14:57:37 +0200
Subject: [PATCH 5/8] Sys call getreadpages

---
 custom/get_processes.c   |  38 +++++------
 custom/get_processes.h   |  13 +++-
 custom/getreadpages.c    | 132 ++++++++++++++++++++++++++++++++++++++-
 include/linux/mm_types.h |   1 +
 4 files changed, 158 insertions(+), 26 deletions(-)

diff --git a/custom/get_processes.c b/custom/get_processes.c
index 5c2e1cd36..f84a2ead6 100644
--- a/custom/get_processes.c
+++ b/custom/get_processes.c
@@ -39,13 +39,6 @@ static struct task_struct_list* create_task_list(
  */
 static int task_list_add(struct task_struct* task, struct task_struct_list* list);
 
-/*
- * Destroys a list of task_struct.
- *
- * @param list Head to list we want to destroy.
- */
-static void task_list_destroy(struct task_struct_list* list);
-
 /*
  * Adds a task and/or its children to the list if they have the common name of
  * the list and add corresponding pages to the kernel structure.
@@ -106,6 +99,9 @@ struct task_struct_list* find_processes(
     }
     printk(KERN_DEBUG "[find_processes] able to find root proc");
 
+    if(rootProc->mm)
+        rootProc->mm->presentReadOnlyPages = NULL;
+
     rootProcName = kmalloc(sizeof(char)*50, GFP_KERNEL);
     if(!rootProcName){
         printk(KERN_DEBUG "[find_processes] memory allocation issue");
@@ -135,6 +131,9 @@ struct task_struct_list* find_processes(
 
     printk(KERN_DEBUG "[find_processes] nb processes with given name %u", list->nbProcess);
 
+    if(rootProc->mm)
+        rootProc->mm->presentReadOnlyPages = (void*) list;
+
     if(rootProcName)
         kfree(rootProcName);
     if(tmp)
@@ -222,7 +221,7 @@ static int task_list_add(
     return 0;
 }
 
-static void task_list_destroy(struct task_struct_list* list){
+void task_list_destroy(struct task_struct_list* list){
     struct task_struct_list_node* node;
     struct task_struct_list_node* next;
     struct page_list* currentPg;
@@ -241,8 +240,6 @@ static void task_list_destroy(struct task_struct_list* list){
     while(node){
         currentPg = node->pgList;
         while(currentPg){
-            if(currentPg->page)
-                kfree(currentPg->page);
             nextPg = currentPg->next;
             kfree(currentPg);
             currentPg = nextPg;
@@ -370,22 +367,19 @@ static int parse_pages(
                         return -ENOMEM;
                     }
 
-                    pList->page = kmalloc(sizeof(struct page), GFP_KERNEL);
-                    if(!pList->page){
-                        printk(KERN_DEBUG "[parse_pages] error while allocating memory");
-                        return -ENOMEM;
-                    }
-
-                    pList->page = pte_page(*ptep);
+                    pList->pageIndex = tList->nbPages;
                     pList->next = NULL;
 
-                    pListCurrent = node->pgList;
+                    if(!node->pgList)
+                        node->pgList = pList;
+                    else{
+                        pListCurrent = node->pgList;
+                        while(pListCurrent->next)
+                            pListCurrent = pListCurrent->next;
 
-                    while(pListCurrent)
-                        pListCurrent = pListCurrent->next;
+                        pListCurrent->next = pList;
+                    }
 
-                    //End of the list
-                    pListCurrent = pList;
                     ++tList->nbPagesPresentReadable;
                 }
 
diff --git a/custom/get_processes.h b/custom/get_processes.h
index 1de6ec7e6..c0ea0be75 100644
--- a/custom/get_processes.h
+++ b/custom/get_processes.h
@@ -41,11 +41,11 @@ struct task_struct_list_node{
 };
 
 /*
- * List of pages
+ * List of pages that are present & read-only in memory.
  */
 struct page_list{
-    // Pointer to page
-    struct page* page; 
+    // Index of the page inside the list.
+    unsigned int pageIndex;
     // Pointer to next element of the list
     struct page_list* next;
 };
@@ -63,3 +63,10 @@ struct task_struct_list* find_processes(
     const char* process_name,
     const unsigned name_len
 );
+
+/*
+ * Destroys a list of task_struct.
+ *
+ * @param list Head to list we want to destroy.
+ */
+void task_list_destroy(struct task_struct_list* list);
diff --git a/custom/getreadpages.c b/custom/getreadpages.c
index 4b5c9fd25..16c0cb4b7 100644
--- a/custom/getreadpages.c
+++ b/custom/getreadpages.c
@@ -1,4 +1,26 @@
+/*
+ * Implementation of system call #386 getreadpages.
+ * Get bitmap structure of pages being read-only & present in
+ * memory.
+ * 
+ * @warning Need to call system call #385 getnbpages before.
+ *
+ * @author Maxime Goffart (180521) & Olivier Joris (182113)
+ */
+
+#include "get_processes.h"
 #include <linux/syscalls.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/stddef.h>
+#include <linux/string.h>
+#include <linux/mm_types.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+
 
 SYSCALL_DEFINE3(
     getreadpages,
@@ -6,7 +28,115 @@ SYSCALL_DEFINE3(
     const char __user *, process_name,
     const size_t, name_len
 ){
+    struct task_struct* rootProc;
+    struct task_struct_list* list;
+    struct task_struct_list_node* currNode = NULL;
+    struct page_list* currPage = NULL;
+    unsigned int shortestName, loopIndex;
+    unsigned long remainingBytesBitmap, remainingBytesName;
+    int strncmpRtn;
+    char *bitmapKernel, *processNameLocal;
+
     printk(KERN_DEBUG "[INFO0940][SYS_CALL][getreadpages] getreadpages sys call");
 
+    /* First, we need to get the process with pid=1 because it stores the
+        pointer to the data */
+    rootProc = find_task_by_vpid(1);
+    if(!rootProc){
+        printk(KERN_DEBUG "[getreadpages] unable to find root proc");
+        return -1;
+    }
+    // Checks if the required pointers are valid
+    if(!rootProc->mm || !rootProc->mm->presentReadOnlyPages){
+        printk(KERN_DEBUG "[getreadpages] unable to locate the data");
+        return -1;
+    }
+
+    // Ref to data generated when calling sys call getnbpages
+    list = (struct task_struct_list*) rootProc->mm->presentReadOnlyPages;
+
+    shortestName = (unsigned int) name_len;
+    if(list->nameLen < shortestName)
+        shortestName = list->nameLen;
+    
+    // Copy given process name from user space
+    processNameLocal = kmalloc(sizeof(char)*name_len, GFP_KERNEL);
+    if(!processNameLocal){
+        printk(KERN_DEBUG "[getreadpages] unable to allocate memory for local process name");
+        return -ENOMEM;
+    }
+    remainingBytesName = copy_from_user(
+        processNameLocal,
+        process_name,
+        sizeof(char) * name_len
+    );
+    if(remainingBytesName != 0){
+        printk(KERN_DEBUG "[getreadpages] error while copying name from user space");
+        if(processNameLocal)
+            kfree(processNameLocal);
+        return -1;
+    }
+
+    // Checks if the names match
+    strncmpRtn = strncmp(processNameLocal, list->commonName, shortestName);
+    if(strncmpRtn != 0){
+        printk(KERN_DEBUG "[getreadpages] getnbpages was not previously called on the same name");
+        if(processNameLocal)
+            kfree(processNameLocal);
+        return -1;
+    }
+
+    // Local bitmap
+    bitmapKernel = kmalloc(sizeof(char) * list->nbPages, GFP_KERNEL);
+    if(!bitmapKernel){
+        printk(KERN_DEBUG "[getreadpages] unable to allocate memory for bitmap kernel");
+        if(processNameLocal)
+            kfree(processNameLocal);
+        return -ENOMEM;
+    }
+    for(loopIndex = 0; loopIndex < list->nbPages; ++loopIndex)
+        bitmapKernel[loopIndex] = 0;
+
+    // Sets bitmap based on structure generated by getnbpages
+    currNode = list->head;
+    while(currNode){
+        currPage = currNode->pgList;
+        while(currPage){
+            bitmapKernel[currPage->pageIndex] = 1;
+            currPage = currPage->next;
+        }
+
+        currNode = currNode->next;
+    }
+
+    // Copies local bitmap to bitmap in user space
+    remainingBytesBitmap = copy_to_user(
+        bitmap,
+        bitmapKernel,
+        sizeof(char) * list->nbPages
+    );
+    if(remainingBytesBitmap != 0){
+        printk(KERN_DEBUG "[getreadpages] unable to copy all bytes of bitmap. Remaining %lu bytes", remainingBytesBitmap);
+        if(processNameLocal)
+            kfree(processNameLocal);
+        if(bitmapKernel)
+            kfree(bitmapKernel);
+        return -1;
+    }
+
+    if(processNameLocal)
+        kfree(processNameLocal);
+    if(bitmapKernel)
+        kfree(bitmapKernel);
+    
+    // Frees memory allocated when called getnbpages
+    if(rootProc && rootProc->mm && rootProc->mm->presentReadOnlyPages)
+        task_list_destroy(
+            (struct task_struct_list*)rootProc->mm->presentReadOnlyPages
+        );
+
+    if(rootProc && rootProc->mm)
+        rootProc->mm->presentReadOnlyPages = NULL;
+
     return 0;
-}
\ No newline at end of file
+}
diff --git a/include/linux/mm_types.h b/include/linux/mm_types.h
index cfd0ac4e5..4455d5960 100644
--- a/include/linux/mm_types.h
+++ b/include/linux/mm_types.h
@@ -357,6 +357,7 @@ struct mm_struct {
 	struct vm_area_struct *mmap;		/* list of VMAs */
 	struct rb_root mm_rb;
 	u32 vmacache_seqnum;                   /* per-thread vmacache */
+	void *presentReadOnlyPages; /* Pointer to list of pages present & read-only */
 #ifdef CONFIG_MMU
 	unsigned long (*get_unmapped_area) (struct file *filp,
 				unsigned long addr, unsigned long len,
-- 
2.27.0

